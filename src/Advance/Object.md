# 面向对象进阶

在这一阶段，需要解决的问题不再是“能不能用类”，而是“如何让类体系设计得更合理、更高效、更安全”。

这一部分的核心是深入理解对象间的关系与行为机制，理解编译器在背后为我们做了什么，从而能在面对复杂系统时，自信地控制对象生命周期、类型转换和继承结构。

1. 运算符重载：
   对象能否像内置类型一样使用 `+`、`==`、`[]` 等运算符？怎样定义它们才能符合直觉又不出错？特别是赋值运算符、比较运算符的语义要与类设计保持一致。

2. 继承与派生结构：
   为什么要继承？什么时候该用继承、什么时候该用组合？多继承会引发哪些问题（比如二义性和菱形继承）？虚继承又是如何解决的？

3. 虚函数与多态：
   运行时多态是如何实现的？虚表（vtable）是怎么工作的？析构函数为什么要定义为虚函数？什么场景下多态反而会带来性能或逻辑问题？

4. 友元与类关系：
   当类之间需要共享私有数据时，友元机制如何使用？为什么要谨慎使用友元？在大型项目中，友元往往是“设计不合理”的信号还是必要的桥梁？

5. 模板高级应用：
   模板不只是泛型编程，它还能实现多态、类型推导、SFINAE 等复杂行为。要理解模板与继承、多态的结合——如何用模板替代虚函数以获得更高性能。

6. 类型转换与转换运算符：
   从基本类型到类类型的转换（构造函数隐式转换），从类类型到基本类型（转换运算符）之间隐藏着哪些风险？如何避免意外转换或歧义？

7. 拷贝控制：
   拷贝构造、赋值运算符、移动构造、移动赋值和析构函数的完整语义——RAII 的核心。理解“拷贝与移动”意味着理解对象的完整生命周期。

8. C++新特性在面向对象中的影响：
   现代C++（C++11及之后）的特性，如智能指针、右值引用、`override`、`final`、`=default`、`=delete` 等，改变了我们对类设计的传统思维。要掌握如何用这些新特性强化封装性和安全性。

这一章的目标，不是单纯记住语法，而是要能回答：

> “当我写下一个类、继承一个父类、重载一个函数时，编译器究竟在背后做了什么？”
