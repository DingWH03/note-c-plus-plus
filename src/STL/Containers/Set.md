# std::set

`std::set` 是一个排序的集合容器，它存储唯一的元素，并根据元素的顺序进行自动排序。与 `std::list` 不同，`std::set` 提供了对元素的高效查找、插入和删除操作，但不支持直接的索引访问。其底层通常是基于平衡二叉树实现（如红黑树），因此在查找、插入和删除操作上的时间复杂度通常为 O(log n)。

## 1. 引入

```C++
#include <set>
```

## 2. 存储方式

`std::set` 是基于平衡二叉树（通常是红黑树）实现的容器。与 `std::list` 和 `std::vector` 不同，`std::set` 具有自动排序的特性，元素会按升序（默认情况下）进行排列。每个元素都是唯一的，无法存储重复的元素。

在 `std::set` 中，元素会以节点的形式存储，每个节点包含一个元素以及指向父节点、左子节点和右子节点的指针。通过这种方式，`std::set` 保证了所有元素的排序特性，并支持高效的查找、插入和删除操作。

* **插入**：由于元素在插入时会自动排序并且不允许重复，插入一个新元素的时间复杂度为 O(log n)，这也保证了元素始终保持有序。
* **查找**：在 `std::set` 中查找元素的时间复杂度为 O(log n)，这是因为它依赖于平衡二叉树的结构。
* **删除**：删除操作也有 O(log n) 的时间复杂度，因为删除节点时需要保持树的平衡。

与 `std::vector` 和 `std::list` 不同，`std::set` 的元素是按照某种顺序排列的，因此它支持基于顺序的迭代。由于不允许重复元素，`std::set` 会自动忽略重复的插入请求。

尽管 `std::set` 提供了很高效的插入、删除和查找操作，但它并不支持快速的随机访问。要访问集合中的某个元素，必须按顺序遍历元素，无法通过索引直接访问。
